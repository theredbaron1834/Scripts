#!/usr/bin/env bash

## script info
# name: resizescreen.sh
# author: theredbaron1834
# purpose: a simple script to give you a boosted virtual resolution
# last updated: august 2014
# dependencies:
# - bash v4
# - xrandr
# - findutils
# optional dependencies:
# - one of the following:
#   - dc
#   - busybox dc
#   - awk
#   - busybox awk

## declare vars
shopt -os nounset
declare    awk_one_liner=''  # se
declare    dependency=''     # se
declare    dsp_name=''       # display name, must be string, letters + numbers
declare -i dsp_max_w=0       # display max width
declare -i dsp_max_h=0       # display max height
declare    boost=''          # se
declare -i boost_int=0       # se
declare    old_boost=''      # must be string, bash can't handle decimal numbers
declare -i old_boost_int=0   # se
declare    regex=''          # se
declare -i ret_val=999       # 999 is safe default, functions return 1 to 10
declare    scale=''          # must be string, bash can't handle decimal numbers
declare    scr_cst_wh=''     # screen custom width x height
declare -i scr_cur_w=0       # screen current width
declare -i scr_cur_h=0       # screen current height
declare -i scr_new_w=0       # screen new width
declare -i scr_new_h=0       # screen new height
declare -a xrandr_info=()    # se

## define functions
# die() is called if we have a fatal error, eg
#   some_important_command || die 'command failed' $LINENO 1
#
# three args:
# - $1, error message, string
# - $2, $LINENO, integer
# - $3, exit code, integer
# 
# no return value
die() {
  if
    (( $# == 3 ))
  then
    echo "$BASH_SOURCE: line $2: ERROR, $1" > /dev/stderr
    exit $3
  else
    echo "$BASH_SOURCE: unspecified error." > /dev/stderr
    exit 999
  fi
}

# usage() prints script usage info,
# then exits cleanly
#
# no args
#
# no return value
usage() {
  cat <<END_USAGE
Usage:
  $BASH_SOURCE --boost [-]xx[%]
  $BASH_SOURCE --reset

Options:
  -b     --boost    How much to boost screen size by, percentage value.

                    For example, '--boost 25%' would allow you to see 25% more
                    of the windows you have open. If that makes text too small
                    to read, '--boost -5%' would adjust it down to 20%.

                    Recommended range is 25% to 50%. Computers with a
                    small screen (eg netbooks) should use a value closer
                    to 25%, computers with a large screen but small display 
                    (eg old laptops with a 1024x768 display) should use
                    a value closer to 50%.
  -h     --help     Display this help.
  -r     --reset    Reset screen size to display resolution.
  -s     --screen   Boost screen size to this resolution. For example,
                    '--screen 1920x1080'.
END_USAGE
  exit 0
}

# reset() resets screen size to display resolution,
# then exits cleanly
#
# no args
#
# no return value
reset() {
  xrandr --output $dsp_name \
         --mode ${dsp_max_w}x${dsp_max_h} \
         --panning 0x0 \
         --scale 1x1
  exit 0
}

# get_answer() gets the user to give the answer to an equation,
# if dc and awk aren't installed
#
# 1 arg:
# - $1, equation to calculate, string
#
# returns a string
get_answer() {
  local equation="$1"
  local answer=''
  
  read -p "Please manually calculate ${equation}: " answer
  echo $answer
}

# check_boost() does a sanity check on $boost_int,
# and performs an adjustment if <0
#
# no args
#
# returns 0 if $boost_int is sane, >25 and <50
# returns 1 if $boost_int isn't sane, <25 or >50, hasn't been adjusted
# returns 2 if $boost_int isn't sane, <25 or >50, has been adjusted
check_boost() {
  local -i my_ret_val=999

  if
    (( $boost_int < 0 ))
  then
    awk_one_liner="BEGIN{ print (($scr_cur_w / $dsp_max_w) * 100) - 100; }"
    old_boost=$(
      dc         <<< "5 k $scr_cur_w $dsp_max_w / 100 * 100 - p" 2>/dev/null || \
      busybox dc <<< "$scr_cur_w $dsp_max_w / 100 * 100 - p"     2>/dev/null || \
      awk         -- "$awk_one_liner"                            2>/dev/null || \
      busybox awk -- "$awk_one_liner"                            2>/dev/null || \
      get_answer "(($scr_cur_w / $dsp_max_w) * 100) - 100"
    )
    # round to nearest integer
    old_boost_int=$(printf '%.0f' $old_boost)
    boost_int=$(( $old_boost_int + $boost_int ))
    if
      (( $boost_int < 25 )) || \
      (( $boost_int > 50 ))
    then
      my_ret_val=2
    fi
  elif
    (( $boost_int < 25 )) || \
    (( $boost_int > 50 ))
  then
    my_ret_val=1
  else
    my_ret_val=0
  fi

  return $my_ret_val
}

# check_screen() does a sanity check on $scr_new_w and $scr_new_h
#
# no args
#
# returns 0 if $scr_new_w and $scr_new_h are sane
# returns 1 otherwise
check_screen() {
  local -i min_sane_w=0
  local -i max_sane_w=0
  local -i min_sane_h=0
  local -i max_sane_h=0
  local -i my_ret_val=999

  # minimum sane width = 1.25 x display max width
  # maximum sane width = 1.5 x display max width
  # same, as above, for height
  min_sane_w=$(( ($dsp_max_w * 125) / 100 ))
  max_sane_w=$(( ($dsp_max_w * 150) / 100 ))
  min_sane_h=$(( ($dsp_max_h * 125) / 100 ))
  max_sane_h=$(( ($dsp_max_h * 150) / 100 ))

  if
    (( $scr_new_w < $min_sane_w )) || \
    (( $scr_new_w > $max_sane_w ))
  then
    my_ret_val=1
  elif
    (( $scr_new_h < $min_sane_h )) || \
    (( $scr_new_h > $max_sane_h ))
  then
    my_ret_val=1
  else
    my_ret_val=0
  fi

  return $my_ret_val    
}

## assign vars
# check dependencies
for dependency in xargs xrandr
do
  command -v $dependency >/dev/null || \
    die "missing dependency: '$dependency'." $LINENO 1
done

# read xrandr output into array $xrandr_info
# quotes are necessary
readarray -t xrandr_info <<< "$(xrandr)"

regex="^Screen 0: minimum [0-9]+ x [0-9]+, current ([0-9]+) x ([0-9]+)"
if
  [[ ${xrandr_info[0]} =~ $regex ]]
then
  scr_cur_w=${BASH_REMATCH[1]}
  scr_cur_h=${BASH_REMATCH[2]}
else
  die "couldn't match regex." $LINENO 2
fi

regex="^([A-Z0-9]+) connected primary"
if
  [[ ${xrandr_info[1]} =~ $regex ]] || \
  [[ ${xrandr_info[2]} =~ $regex ]]
then
  dsp_name=${BASH_REMATCH[1]}
else
  die "couldn't match regex." $LINENO 2
fi

# see xrandr | od -t a for number of spaces to match
# + (at end of regex) indicates max res
regex="^ {3}([0-9]+)x([0-9]+) {7}[0-9]{2}\.[0-9].\+"
if
  [[ ${xrandr_info[2]} =~ $regex ]] || \
  [[ ${xrandr_info[3]} =~ $regex ]]
then
  dsp_max_w=${BASH_REMATCH[1]}
  dsp_max_h=${BASH_REMATCH[2]}
else
  die "couldn't match regex." $LINENO 2
fi

## process options
while
  (( $# >= 1 ))
do
  # use case rather than if/elif/else,
  # in future we may add more than 3 options to script
  case $1 in
    '-b' |  '--boost') boost=$2; shift 2;;
    '-h' |   '--help') usage;;
    '-r' |  '--reset') reset;;
    '-s' | '--screen') scr_cst_wh=$2; shift 2;;
                    *) echo "WARNING, option '$1' not recognised."; shift 1;;
  esac
done

## body of script
# handle --boost option
if
  [[ ${boost:+set} = set ]]
then
  if
    [[ $boost != ?[0-9]* ]]
  then
    echo "WARNING, \'--boost $boost\' is not a number, defaulting to \
          \'--boost 35%\'." | xargs
    boost_int=35
  else
    # strip percent char (%) and round to nearest integer
    # $boost may already be an integer,
    # but one superfluous call to printf doesn't matter
    boost_int=$(printf '%.0f' ${boost%\%})

    # check $boost_int is sane value
    check_boost
    ret_val=$?
    if
      (( $ret_val == 1 ))
    then
      echo "WARNING, \'--boost $boost\' is outside the recommended range \
            (25 to 50%)." | xargs
    elif
      (( $ret_val == 2 ))
    then
      echo "WARNING, adjusted value \'--boost ${boost_int}%\' is outside the \
            recommended range (25 to 50%)." | xargs
    fi      
  fi

# handle --screen option
elif
  [[ ${scr_cst_wh:+set} = set ]]
then
  regex="^([0-9]+)x([0-9]+)$"
  if
    [[ $scr_cst_wh =~ $regex ]]
  then
    scr_new_w=${BASH_REMATCH[1]}
    scr_new_h=${BASH_REMATCH[2]}
    check_screen
    ret_val=$?
    if
      (( $ret_val == 1 ))
    then
      echo "WARNING, '--screen $scr_cst_wh' is outside the recommended range."
    fi
  else
    scr_new_w=$(( ($dsp_max_w * 135) / 100 ))
    scr_new_h=$(( ($dsp_max_h * 135) / 100 ))
    echo "WARNING, argument for the \'--screen\' option must be
          \'number x number\' without spaces, eg \'--screen 1920x1080\'. \
          Defaulting to \'--screen ${scr_new_w}x${scr_new_h}\'." | xargs
  fi

# handle no options
else
  echo "WARNING, you didn\'t specify the \'--boost\' option or the \'--screen\'
        option, defaulting to \'--boost 35%\'." | xargs
  boost_int=35
fi

if
  (( $boost_int != 0 ))
then
  scr_new_w=$(( ($dsp_max_w * ($boost_int + 100)) / 100 ))
  scr_new_h=$(( ($dsp_max_h * ($boost_int + 100)) / 100 ))
fi

awk_one_liner="BEGIN{ print $scr_new_w / $dsp_max_w; }"
scale=$(
  dc         <<< "5 k $scr_new_w $dsp_max_w / p" 2>/dev/null || \
  busybox dc <<< "$scr_new_w $dsp_max_w / p"     2>/dev/null || \
  awk         -- "$awk_one_liner"                2>/dev/null || \
  busybox awk -- "$awk_one_liner"                2>/dev/null || \
  get_answer "$scr_new_w / $dsp_max_w"
)

# feedback to user
echo "Display resolution....: ${dsp_max_w}x${dsp_max_h}"
echo "Current screen size...: ${scr_cur_w}x${scr_cur_h}"
echo "New screen size.......: ${scr_new_w}x${scr_new_h}"
echo "Scale.................: $scale"
echo "Command to run........: xrandr --output $dsp_name \
                                     --mode ${dsp_max_w}x${dsp_max_h} \
                                     --panning ${scr_new_w}x${scr_new_h} \
                                     --scale ${scale}x${scale}" | xargs

# good idea to give user a chance to abort
echo "WARNING, running command in 5 seconds, press 'Ctrl-C' to abort."
sleep 5
xrandr --output $dsp_name \
       --mode ${dsp_max_w}x${dsp_max_h} \
       --panning ${scr_new_w}x${scr_new_h} \
       --scale ${scale}x${scale}

# exit cleanly
exit 0
