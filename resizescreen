#!/usr/bin/env bash

## script info
# name: resizescreen.sh
# author: theredbaron1834
# purpose: a simple script to give you a boosted screen size
# last updated: august 2014
# dependencies:
# - bash v4
# - xrandr
# - findutils (xargs)
# - ncurses (tput)
# optional dependencies:
# - one of the following:
#   - dc
#   - busybox dc
#   - awk
#   - busybox awk

## declare vars
shopt -os nounset
declare    awk_one_liner='' # se
declare    blu=''           # se
declare    boost=''         # user supplied boost val, eg 35.7%
declare -i boost_int=0      # boost val rounded to nearest integer, eg 36
declare -i boost_default=0  # boost default val, eg 25
declare    boost_old=''     # must be string, bash can't handle decimal numbers
declare -i boost_old_int=0  # se
declare    clr=''           # se
declare    dependency=''    # se
declare    dsp_name=''      # display name, must be string, letters + numbers
declare -i dsp_max_w=0      # display max width
declare -i dsp_max_h=0      # display max height
declare    grn=''           # se
declare    red=''           # se
declare    regex=''         # se
declare -i ret_val=999      # 999 is safe default, functions return 1 to 10
declare    scale=''         # must be string, bash can't handle decimal numbers
declare    scr_cst_wh=''    # screen custom width x height
declare -i scr_cur_w=0      # screen current width
declare -i scr_cur_h=0      # screen current height
declare -i scr_new_w=0      # screen new width
declare -i scr_new_h=0      # screen new height
declare -i term_colors=0    # se
declare -a xrandr_info=()   # se

## define functions
# usage() prints script usage info, then exits
#
# no args
#
# no return value
usage() {
  cat <<END_USAGE
Usage:
  $BASH_SOURCE --boost [-]xx[%]
  $BASH_SOURCE --reset

Options:
  -b   --boost     How much to boost screen size by, percentage value.

                   For example, ${grn}--boost 40%${clr} would allow you to
                   see 40% more of the windows you have open. If that makes
                   text too small to read, try running ${grn}--boost -5%${clr}
                   a few times until you find a screen size you like.

                   Using a negative value will make the script
                   adjust the previously used boost value, so in the example
                   above ${grn}--boost 40%${clr} becomes ${grn}--boost 35%${clr},
                   then ${grn}30%${clr}, then ${grn}25%${clr}, etc.

                   Recommended range is 25 to 50%. Computers with a
                   small screen (eg netbooks) should use a value closer
                   to 25%, computers with a large screen but small display
                   (eg old laptops with a 1024x768 display) should use
                   a value closer to 50%.
  -d   --default   This script has a default boost value of
                   ${grn}--boost 35%${clr}.
    
                   If you would like to make the current boost value
                   the new default, use this option. For example,
                     ${grn}$BASH_SOURCE --boost 40%${clr} followed by
                     ${grn}$BASH_SOURCE --default${clr} followed by
                     ${grn}$BASH_SOURCE --reset${clr} followed by
                     ${grn}$BASH_SOURCE${clr} 
                   would result in a boost value of ${grn}--boost 40%${clr}.

                   Note this option creates a file in your home directory,
                   ${grn}~/.resizescreen${clr}.
  -h   --help      Display this help.
  -r   --reset     Reset screen size to display resolution.
  -s   --screen    Boost screen size to this resolution. For example,
                   ${grn}--screen 1920x1080${clr}.
END_USAGE
  exit 0
}

# die() is called if we have a fatal error, eg
#   some_important_command || die 'command failed' $LINENO 1
# prints an error message, then exits
#
# three args:
# - $1, error message, string
# - $2, $LINENO, integer
# - $3, exit code, integer
# 
# no return value
die() {
  if
    (( $# == 3 ))
  then
    # use xargs to collapse whitespace in long error messages
    echo "$BASH_SOURCE: line $2: ${red}Error${clr}, $1" | xargs >/dev/stderr
    exit $3
  else
    echo "$BASH_SOURCE: ${red}unspecified error${clr}." >/dev/stderr
    exit 999
  fi
}

# warn() prints a warning message
#
# one arg:
# - $1, warning message, string
#
# no return value
warn() {
  # use xargs to collapse whitespace in long warning messages
  echo "${blu}Warning${clr}, $1" | xargs
}

# reset() resets screen size to display resolution, then exits
#
# no args
#
# no return value
reset() {
  xrandr --output $dsp_name \
         --mode ${dsp_max_w}x${dsp_max_h} \
         --panning 0x0 \
         --scale 1x1
  exit 0
}

# get_answer() gets the user to give the answer to an equation,
# this is a fallback if dc and awk aren't installed
#
# one arg:
# - $1, equation to calculate, string
#
# returns a string
get_answer() {
  local equation="$1"
  local answer=''
  
  read -p "Please manually calculate ${equation}: " answer
  echo $answer
}

# get_boost_old() calculates the previously used --boost setting
#
# no args
#
# no return value
get_boost_old() {
  awk_one_liner="BEGIN{ print (($scr_cur_w / $dsp_max_w) * 100) - 100; }"
  boost_old=$(
    dc         <<< "5 k $scr_cur_w $dsp_max_w / 100 * 100 - p" 2>/dev/null || \
    busybox dc <<< "$scr_cur_w $dsp_max_w / 100 * 100 - p"     2>/dev/null || \
    awk         -- "$awk_one_liner"                            2>/dev/null || \
    busybox awk -- "$awk_one_liner"                            2>/dev/null || \
    get_answer "(($scr_cur_w / $dsp_max_w) * 100) - 100"
  )
  # round to nearest integer
  boost_old_int=$(printf '%.0f' $boost_old)
}

# check_boost() does a sanity check on a percentage value,
# either $boost_int or $boost_old_int
#
# one arg:
# $1, percentage value to check, integer
#
# returns 0 if $percentage is sane, 25..50
# returns 1 if $percentage isn't sane, 0..24 or >50
# returns 2 if $percentage isn't sane, <0
check_boost() {
  local -i percentage=$1

  if
    (( $percentage >= 25 )) && \
    (( $percentage <= 50 ))
  then
    return 0
  elif
    (( $percentage >= 0 ))
  then
    return 1
  else
    return 2
  fi
}

# check_screen() does a sanity check on $scr_new_w and $scr_new_h
#
# no args
#
# returns 0 if $scr_new_w and $scr_new_h are sane
# returns 1 otherwise
check_screen() {
  local -i min_sane_w=0
  local -i max_sane_w=0
  local -i min_sane_h=0
  local -i max_sane_h=0

  # minimum sane width = 1.25 x display max width
  # maximum sane width = 1.5 x display max width
  # same, as above, for height
  min_sane_w=$(( ($dsp_max_w * 125) / 100 ))
  max_sane_w=$(( ($dsp_max_w * 150) / 100 ))
  min_sane_h=$(( ($dsp_max_h * 125) / 100 ))
  max_sane_h=$(( ($dsp_max_h * 150) / 100 ))

  if
    (( $scr_new_w < $min_sane_w )) || \
    (( $scr_new_w > $max_sane_w )) || \
    (( $scr_new_h < $min_sane_h )) || \
    (( $scr_new_h > $max_sane_h ))
  then
    return 1
  else
    return 0
  fi
}

# save_boost_default() saves the previously used --boost setting
# to a file in the user's home directory, then exits
#
# no args
#
# no return value
save_boost_default() {
  get_boost_old

  check_boost $boost_old_int
  ret_val=$?

  if
    (( $ret_val == 0 ))
  then
    echo $boost_old_int > ~/.resizescreen
    echo "Set default ${grn}--boost ${boost_old_int}%${clr}."
    exit 0
  else
    die "sanity check failed. Not setting a ${grn}--boost${clr} value outside
         the recommended range (25 to 50%) as default." $LINENO 3
  fi
}

## assign vars
# check dependencies
for dependency in tput xargs xrandr
do
  command -v $dependency >/dev/null || \
    die "dependency check failed. $dependency is not installed?" $LINENO 1
done

term_colors=$(tput colors)
if
  (( $term_colors >= 8 ))
then
  red="$(tput bold)$(tput setaf 1)"
  grn="$(tput bold)$(tput setaf 2)"
  blu="$(tput bold)$(tput setaf 4)"
  clr="$(tput sgr0)"
fi

# read xrandr output into array $xrandr_info
# quotes are necessary
readarray -t xrandr_info <<< "$(xrandr)"

regex="^Screen 0: minimum [0-9]+ x [0-9]+, current ([0-9]+) x ([0-9]+)"
if
  [[ ${xrandr_info[0]} =~ $regex ]]
then
  scr_cur_w=${BASH_REMATCH[1]}
  scr_cur_h=${BASH_REMATCH[2]}
else
  die "regex match failed." $LINENO 2
fi

regex="^([A-Z0-9]+) connected primary"
if
  [[ ${xrandr_info[1]} =~ $regex ]] || \
  [[ ${xrandr_info[2]} =~ $regex ]]
then
  dsp_name=${BASH_REMATCH[1]}
else
  die "regex match failed." $LINENO 2
fi

# see xrandr | od -t a for number of spaces to match
# + (at end of regex) indicates max res
regex="^ {3}([0-9]+)x([0-9]+) {7}[0-9]{2}\.[0-9].\+"
if
  [[ ${xrandr_info[2]} =~ $regex ]] || \
  [[ ${xrandr_info[3]} =~ $regex ]]
then
  dsp_max_w=${BASH_REMATCH[1]}
  dsp_max_h=${BASH_REMATCH[2]}
else
  die "regex match failed." $LINENO 2
fi

# script default is 35, see usage()
if
  [[ -r ~/.resizescreen ]]
then
  read boost_default < ~/.resizescreen
else
  boost_default=35
fi

## process options
while
  (( $# >= 1 ))
do
  case $1 in
    '-b' |   '--boost') boost=$2; shift 2;;
    '-d' | '--default') save_boost_default;;
    '-h' |    '--help') usage;;
    '-r' |   '--reset') reset;;
    '-s' |  '--screen') scr_cst_wh=$2; shift 2;;
                     *) warn "option ${grn}$1${clr} not recognised."; shift 1;;
  esac
done

## body of script
# handle --boost option
if
  [[ ${boost:+set} = set ]]
then
  regex="^-?[.0-9]+%?$"
  if
    [[ $boost =~ $regex ]]
  then
    # strip percent char and round to nearest integer
    boost_int=$(printf '%.0f' ${boost%\%})

    # sanity check $boost_int
    check_boost $boost_int
    ret_val=$?

    # warn user if $boost_int is 0..24 or >50
    if
      (( $ret_val == 1 ))
    then
      warn "${grn}--boost ${boost_int}%${clr} is outside the recommended range
            (25 to 50%)."
    # perform adjustment if $boost_int is <0
    elif
      (( $ret_val == 2 ))
    then
      get_boost_old
      boost_int=$(( $boost_old_int + $boost_int ))
      check_boost $boost_int || \
        warn "adjusted value ${grn}--boost ${boost_int}%${clr} is outside the
              recommended range (25 to 50%)."
    fi      
  else
    warn "${grn}--boost $boost${clr} is not a number,
          defaulting to ${grn}--boost ${boost_default}%${clr}."
    boost_int=$boost_default
  fi

# handle --screen option
elif
  [[ ${scr_cst_wh:+set} = set ]]
then
  regex="^([0-9]+)x([0-9]+)$"
  if
    [[ $scr_cst_wh =~ $regex ]]
  then
    scr_new_w=${BASH_REMATCH[1]}
    scr_new_h=${BASH_REMATCH[2]}
    check_screen || \
      warn "${grn}--screen ${scr_cst_wh}${clr} is outside the recommended range."
  else
    scr_new_w=$(( ($dsp_max_w * ($boost_default + 100)) / 100 ))
    scr_new_h=$(( ($dsp_max_h * ($boost_default + 100)) / 100 ))
    warn "argument for the ${grn}--screen${clr} option must be
          ${grn}number x number{clr} without spaces, eg 
          ${grn}--screen 1920x1080${clr}.
          Defaulting to ${grn}--screen ${scr_new_w}x${scr_new_h}${clr}."
  fi

# handle no options
else
  warn "no ${grn}--boost${clr} or ${grn}--screen${clr} option in script args,
        defaulting to ${grn}--boost ${boost_default}%${clr}."
  boost_int=$boost_default
fi

# calculate new values for $scr_new_w and $scr_new_h
# if we are using the --boost option
if
  (( $scr_new_w == 0 ))
then
  if
    (( $boost_int != 0 ))
  then
    scr_new_w=$(( ($dsp_max_w * ($boost_int + 100)) / 100 ))
    scr_new_h=$(( ($dsp_max_h * ($boost_int + 100)) / 100 ))
  else
    reset    
  fi
fi

# calculate $scale for both options, --boost or --screen
awk_one_liner="BEGIN{ print $scr_new_w / $dsp_max_w; }"
scale=$(
  dc         <<< "5 k $scr_new_w $dsp_max_w / p" 2>/dev/null || \
  busybox dc <<< "$scr_new_w $dsp_max_w / p"     2>/dev/null || \
  awk         -- "$awk_one_liner"                2>/dev/null || \
  busybox awk -- "$awk_one_liner"                2>/dev/null || \
  get_answer "$scr_new_w / $dsp_max_w"
)

# feedback to user
echo "Display resolution....: ${dsp_max_w}x${dsp_max_h}"
echo "Current screen size...: ${scr_cur_w}x${scr_cur_h}"
echo "New screen size.......: ${scr_new_w}x${scr_new_h}"
echo "Scale.................: $scale"
echo "Command to run........: xrandr --output $dsp_name
                                     --mode ${dsp_max_w}x${dsp_max_h}
                                     --panning ${scr_new_w}x${scr_new_h}
                                     --scale ${scale}x${scale}" | xargs

# good idea to give user a chance to abort
warn "running command in 5 seconds, press ${grn}Ctrl-C${clr} to abort."
# -t 5 option makes the read command time out in 5 seconds
# -N 0 option ensures no keypress can interrupt the read command, except Ctrl-C
read -t 5 -N 0
xrandr --output $dsp_name \
       --mode ${dsp_max_w}x${dsp_max_h} \
       --panning ${scr_new_w}x${scr_new_h} \
       --scale ${scale}x${scale}

# exit cleanly
exit 0
